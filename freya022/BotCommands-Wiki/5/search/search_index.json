{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the BotCommands wiki! \u00b6 test test 2 test 3 Have a look around the different categories on how to use this framework If you don't find a wiki page you need, you should check out the examples","title":"Home"},{"location":"#welcome-to-the-botcommands-wiki","text":"test test 2 test 3 Have a look around the different categories on how to use this framework If you don't find a wiki page you need, you should check out the examples","title":"Welcome to the BotCommands wiki!"},{"location":"Logging/","text":"The library uses a logger, if no logger is present it will only print errors It is strongly advised you use a logger , it doesn't take you much time to add a logback dependency and some generic logback.xml For a logging tutorial, you can follow JDA's Logging tutorial And then you can choose a logback.xml file, which you have to put in the root of your resources (so in Maven at src/main/resources ) My personal choice for a logback.xml is as such: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <configuration> <timestamp key= \"bySecond\" datePattern= \"yyyyMMdd'T'HHmmss\" /> <appender name= \"STDOUT\" class= \"ch.qos.logback.core.ConsoleAppender\" > <encoder> <!-- Debug pattern --> <!--<pattern>%d{HH:mm:ss.SSS} %boldCyan(%-26.-26thread) %boldRed(%-36.-36class{36}) %boldRed(#%-24.-24method{24}) %boldRed(L%-5.-5line) %boldYellow(%-20.-20logger{0}) %highlight(%-6level) %msg%n%throwable</pattern>--> <!-- Normal pattern, no stack frames --> <pattern> %d{HH:mm:ss.SSS} %boldCyan(%-26.-26thread) %boldYellow(%-20.-20logger{0}) %highlight(%-6level) %msg%n%throwable </pattern> </encoder> </appender> <appender name= \"FILE\" class= \"ch.qos.logback.core.rolling.RollingFileAppender\" > <rollingPolicy class= \"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\" > <!-- daily rollover --> <fileNamePattern> logs/logs-%d{yyyy-MM-dd}.log </fileNamePattern> <!-- keep 90 days' worth of history capped at 3GB total size --> <maxHistory> 90 </maxHistory> <totalSizeCap> 3GB </totalSizeCap> </rollingPolicy> <encoder> <pattern> %d{HH:mm:ss.SSS} %-26.-26thread %-36.-36class{36} #%-24.-24method{24} L%-5.-5line %-20.-20logger{0} %-6level %msg%n%throwable </pattern> </encoder> </appender> <!-- Log JDA and HikariCP on Info while others are on Debug --> <logger name= \"net.dv8tion.jda\" level= \"info\" additivity= \"false\" > <appender-ref ref= \"STDOUT\" /> <appender-ref ref= \"FILE\" /> </logger> <logger name= \"com.zaxxer.hikari\" level= \"info\" additivity= \"false\" > <appender-ref ref= \"STDOUT\" /> <appender-ref ref= \"FILE\" /> </logger> <root level= \"debug\" > <appender-ref ref= \"STDOUT\" /> <appender-ref ref= \"FILE\" /> </root> </configuration>","title":"Logging"},{"location":"misc/Conditional-instancing/","text":"Conditional instancing \u00b6 Conditional instancing lets you enable classes (they may be commands, component handlers or event handlers...) with a predicate method. The predicate is called when the class is trying to get instantiated, if the predicate returns false, the class will not be instantiated (so the constructor won't run) Requirements \u00b6 The method must be public and static It must return a boolean It does not accept any arguments Example \u00b6 Suppose you have a /windows command that only works on Windows, and a /linux command that only works on Linux public class WindowsCommand extends ApplicationCommand { @ConditionalUse //Called when the class is about to get constructed public static boolean canUse () { //Return false if it's not Windows return System . getProperty ( \"os.name\" ). toLowerCase (). contains ( \"windows\" ); } @JDASlashCommand ( name = \"windows\" ) public void execute ( GuildSlashEvent event ) { event . reply ( \"The bot runs on Windows\" ). setEphemeral ( true ). queue (); } } public class LinuxCommand extends ApplicationCommand { @ConditionalUse //Called when the class is about to get constructed public static boolean canUse () { //Return false if it's not Linux final String osName = System . getProperty ( \"os.name\" ). toLowerCase (); return osName . contains ( \"linux\" ) || osName . contains ( \"nix\" ); //Not accurate but should do it, not tested } @JDASlashCommand ( name = \"linux\" ) public void execute ( GuildSlashEvent event ) { event . reply ( \"The bot runs on Linux\" ). setEphemeral ( true ). queue (); } } This would make these commands enable themselves when the running OS corresponds","title":"Conditional instancing"},{"location":"misc/Conditional-instancing/#conditional-instancing","text":"Conditional instancing lets you enable classes (they may be commands, component handlers or event handlers...) with a predicate method. The predicate is called when the class is trying to get instantiated, if the predicate returns false, the class will not be instantiated (so the constructor won't run)","title":"Conditional instancing"},{"location":"misc/Conditional-instancing/#requirements","text":"The method must be public and static It must return a boolean It does not accept any arguments","title":"Requirements"},{"location":"misc/Conditional-instancing/#example","text":"Suppose you have a /windows command that only works on Windows, and a /linux command that only works on Linux public class WindowsCommand extends ApplicationCommand { @ConditionalUse //Called when the class is about to get constructed public static boolean canUse () { //Return false if it's not Windows return System . getProperty ( \"os.name\" ). toLowerCase (). contains ( \"windows\" ); } @JDASlashCommand ( name = \"windows\" ) public void execute ( GuildSlashEvent event ) { event . reply ( \"The bot runs on Windows\" ). setEphemeral ( true ). queue (); } } public class LinuxCommand extends ApplicationCommand { @ConditionalUse //Called when the class is about to get constructed public static boolean canUse () { //Return false if it's not Linux final String osName = System . getProperty ( \"os.name\" ). toLowerCase (); return osName . contains ( \"linux\" ) || osName . contains ( \"nix\" ); //Not accurate but should do it, not tested } @JDASlashCommand ( name = \"linux\" ) public void execute ( GuildSlashEvent event ) { event . reply ( \"The bot runs on Linux\" ). setEphemeral ( true ). queue (); } } This would make these commands enable themselves when the running OS corresponds","title":"Example"},{"location":"misc/Instance-suppliers/","text":"Using instance suppliers \u00b6 Maybe you have some use case where you would need to manually instantiate a command class For this, you can register the instances directly in the ExtensionsBuilder#registerInstanceSupplier How to use it \u00b6 You can register the instance supplier with ExtensionsBuilder#registerInstanceSupplier Example \u00b6 CommandsBuilder . newBuilder () . extensionsBuilder ( extensionsBuilder -> extensionsBuilder . registerInstanceSupplier ( SlashInstanceSupplierTest . class , ignored -> new SlashInstanceSupplierTest ( new SlashInstanceSupplierTest . Dummy ())) ) . build ( jda , \"com.freya02.bot.wiki.instancesupplier.commands\" ); Checking that it works \u00b6 public class SlashInstanceSupplierTest extends ApplicationCommand { private static final Logger LOGGER = Logging . getLogger (); public static class Dummy {} //Making a non-instantiable constructor so only I can construct it public SlashInstanceSupplierTest ( Dummy dummy ) { LOGGER . debug ( \"I got constructed with {}\" , dummy ); } @JDASlashCommand ( name = \"instancesupplier\" ) public void run ( GuildSlashEvent event ) { event . reply ( \"I ran\" ). queue (); } }","title":"Using instance suppliers"},{"location":"misc/Instance-suppliers/#using-instance-suppliers","text":"Maybe you have some use case where you would need to manually instantiate a command class For this, you can register the instances directly in the ExtensionsBuilder#registerInstanceSupplier","title":"Using instance suppliers"},{"location":"misc/Instance-suppliers/#how-to-use-it","text":"You can register the instance supplier with ExtensionsBuilder#registerInstanceSupplier","title":"How to use it"},{"location":"misc/Instance-suppliers/#example","text":"CommandsBuilder . newBuilder () . extensionsBuilder ( extensionsBuilder -> extensionsBuilder . registerInstanceSupplier ( SlashInstanceSupplierTest . class , ignored -> new SlashInstanceSupplierTest ( new SlashInstanceSupplierTest . Dummy ())) ) . build ( jda , \"com.freya02.bot.wiki.instancesupplier.commands\" );","title":"Example"},{"location":"misc/Instance-suppliers/#checking-that-it-works","text":"public class SlashInstanceSupplierTest extends ApplicationCommand { private static final Logger LOGGER = Logging . getLogger (); public static class Dummy {} //Making a non-instantiable constructor so only I can construct it public SlashInstanceSupplierTest ( Dummy dummy ) { LOGGER . debug ( \"I got constructed with {}\" , dummy ); } @JDASlashCommand ( name = \"instancesupplier\" ) public void run ( GuildSlashEvent event ) { event . reply ( \"I ran\" ). queue (); } }","title":"Checking that it works"},{"location":"misc/The-event-waiter/","text":"Using the event waiter \u00b6 You might have situations where you want to wait for any JDA event to occur, for this you could use an event waiter, even if sometimes a state machine is better, in cases when you need to wait for multiple events sequentially No setup is required to use the event waiter, just use the static method EventWaiter#of Example - Simon says \u00b6 The following example uses most of what you'll need: @Description ( \"Do what Simon says\" ) public class SlashWaiterTest extends TextCommand { @JDATextCommand ( name = \"simon\" ) public void execute ( CommandEvent event ) { event . reply ( \"Simon says: say `hi` in less than 5 seconds\" ). queue ( m -> { EventWaiter . of ( GuildMessageReceivedEvent . class ) //Listen to guild messages //Check for the same channel . addPrecondition ( e -> e . getChannel (). equals ( event . getChannel ())) //You can add as many preconditions, // this would avoid doing combinations of booleans in 1 predicate //Check for same author, with message \"hi\" . addPrecondition ( e -> e . getAuthor (). equals ( event . getAuthor ()) && e . getMessage (). getContentRaw (). equals ( \"hi\" )) //Expire on 5 seconds . setTimeout ( 5 , TimeUnit . SECONDS ) //After event waiter has expired, send a timeout message . setOnTimeout (() -> m . reply ( \"Timeout !\" ). queue ()) //After the preconditions have been fulfilled, reply . setOnSuccess ( e -> e . getMessage (). reply ( \"n i c e\" ). queue ()) //Wait for the event (non-blocking) . submit (); }); } }","title":"Using the event waiter"},{"location":"misc/The-event-waiter/#using-the-event-waiter","text":"You might have situations where you want to wait for any JDA event to occur, for this you could use an event waiter, even if sometimes a state machine is better, in cases when you need to wait for multiple events sequentially No setup is required to use the event waiter, just use the static method EventWaiter#of","title":"Using the event waiter"},{"location":"misc/The-event-waiter/#example-simon-says","text":"The following example uses most of what you'll need: @Description ( \"Do what Simon says\" ) public class SlashWaiterTest extends TextCommand { @JDATextCommand ( name = \"simon\" ) public void execute ( CommandEvent event ) { event . reply ( \"Simon says: say `hi` in less than 5 seconds\" ). queue ( m -> { EventWaiter . of ( GuildMessageReceivedEvent . class ) //Listen to guild messages //Check for the same channel . addPrecondition ( e -> e . getChannel (). equals ( event . getChannel ())) //You can add as many preconditions, // this would avoid doing combinations of booleans in 1 predicate //Check for same author, with message \"hi\" . addPrecondition ( e -> e . getAuthor (). equals ( event . getAuthor ()) && e . getMessage (). getContentRaw (). equals ( \"hi\" )) //Expire on 5 seconds . setTimeout ( 5 , TimeUnit . SECONDS ) //After event waiter has expired, send a timeout message . setOnTimeout (() -> m . reply ( \"Timeout !\" ). queue ()) //After the preconditions have been fulfilled, reply . setOnSuccess ( e -> e . getMessage (). reply ( \"n i c e\" ). queue ()) //Wait for the event (non-blocking) . submit (); }); } }","title":"Example - Simon says"},{"location":"using-commands/Context-menu-commands/","text":"Writing context menu commands \u00b6 Context commands are these commands when you right-click on a message, or on a user, and executes an interaction, similarly to slash commands A few keywords \u00b6 [Type] is either User or Message ApplicationCommand - Must be extended by the class which contains applications commands @AppOption - Mandatory on options @JDA[Type]Command - Annotation for methods which marks context commands Making context commands \u00b6 A context command is similar to a slash command - You extend ApplicationCommand on your class and use @JDA[Type]Command on every method you want to be a context menu command Your method has to: * Be public * Have Guild[Type]Event (for guild-only context commands, if not specified explicitly, a context command is guild-only) as first parameter, or a Global[Type]Event for global commands * Be annotated @JDA[Type]Command Examples \u00b6 Basic Quote message message command public class ContextQuote extends ApplicationCommand { @JDAMessageCommand ( name = \"Quote message\" ) public void execute ( GuildMessageEvent event ) { final Message targetMessage = event . getTargetMessage (); event . reply ( \"> \" + targetMessage . getContentRaw ()). queue (); } } Basic Get avatar user command public class ContextAvatar extends ApplicationCommand { @JDAUserCommand ( name = \"Get avatar\" ) public void execute ( GuildUserEvent event ) { final User targetUser = event . getTargetUser (); event . reply ( targetUser . getEffectiveAvatarUrl ()). queue (); } } Updating existing context commands on the fly \u00b6 See the Updating existing commands page","title":"Writing context menu commands"},{"location":"using-commands/Context-menu-commands/#writing-context-menu-commands","text":"Context commands are these commands when you right-click on a message, or on a user, and executes an interaction, similarly to slash commands","title":"Writing context menu commands"},{"location":"using-commands/Context-menu-commands/#a-few-keywords","text":"[Type] is either User or Message ApplicationCommand - Must be extended by the class which contains applications commands @AppOption - Mandatory on options @JDA[Type]Command - Annotation for methods which marks context commands","title":"A few keywords"},{"location":"using-commands/Context-menu-commands/#making-context-commands","text":"A context command is similar to a slash command - You extend ApplicationCommand on your class and use @JDA[Type]Command on every method you want to be a context menu command Your method has to: * Be public * Have Guild[Type]Event (for guild-only context commands, if not specified explicitly, a context command is guild-only) as first parameter, or a Global[Type]Event for global commands * Be annotated @JDA[Type]Command","title":"Making context commands"},{"location":"using-commands/Context-menu-commands/#examples","text":"Basic Quote message message command public class ContextQuote extends ApplicationCommand { @JDAMessageCommand ( name = \"Quote message\" ) public void execute ( GuildMessageEvent event ) { final Message targetMessage = event . getTargetMessage (); event . reply ( \"> \" + targetMessage . getContentRaw ()). queue (); } } Basic Get avatar user command public class ContextAvatar extends ApplicationCommand { @JDAUserCommand ( name = \"Get avatar\" ) public void execute ( GuildUserEvent event ) { final User targetUser = event . getTargetUser (); event . reply ( targetUser . getEffectiveAvatarUrl ()). queue (); } }","title":"Examples"},{"location":"using-commands/Context-menu-commands/#updating-existing-context-commands-on-the-fly","text":"See the Updating existing commands page","title":"Updating existing context commands on the fly"},{"location":"using-commands/Inferred-option-names/","text":"Inferred option names \u00b6 For annotations such as @TextOption or @AppOption , you would need to set a name attribute on them, so it can be displayed on Discord Fortunately, you can make the library take the name of your parameter as the name for your option, all you have to do is to tell your compiler(s) to put the parameter metadata in the compiled classes This should make your code a bit cleaner Adding Java & Kotlin parameters for Maven \u00b6 Java \u00b6 You can add this in your configuration tag: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-compiler-plugin </artifactId> <version> ${compiler.plugin.version} </version> <configuration> <source> ${java.version} </source> <target> ${java.version} </target> <compilerArgs> <!-- Add this --> <compilerArg> -parameters </compilerArg> </compilerArgs> </configuration> </plugin> Kotlin \u00b6 You can add this in your configuration tag: <plugin> <groupId> org.jetbrains.kotlin </groupId> <artifactId> kotlin-maven-plugin </artifactId> <version> ${kotlin.version} </version> <executions> ... </executions> <configuration> <args> <!-- Add this --> <arg> -java-parameters </arg> ... </args> </configuration> </plugin> Adding Java & Kotlin parameters for Gradle \u00b6 Java \u00b6 You can add this in your build.gradle : compileJava { compilerArgs += '-parameters' } Kotlin \u00b6 You can add this in your build.gradle : compileKotlin { kotlinOptions.javaParameters = true }","title":"Inferred option names"},{"location":"using-commands/Inferred-option-names/#inferred-option-names","text":"For annotations such as @TextOption or @AppOption , you would need to set a name attribute on them, so it can be displayed on Discord Fortunately, you can make the library take the name of your parameter as the name for your option, all you have to do is to tell your compiler(s) to put the parameter metadata in the compiled classes This should make your code a bit cleaner","title":"Inferred option names"},{"location":"using-commands/Inferred-option-names/#adding-java-kotlin-parameters-for-maven","text":"","title":"Adding Java &amp; Kotlin parameters for Maven"},{"location":"using-commands/Inferred-option-names/#java","text":"You can add this in your configuration tag: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-compiler-plugin </artifactId> <version> ${compiler.plugin.version} </version> <configuration> <source> ${java.version} </source> <target> ${java.version} </target> <compilerArgs> <!-- Add this --> <compilerArg> -parameters </compilerArg> </compilerArgs> </configuration> </plugin>","title":"Java"},{"location":"using-commands/Inferred-option-names/#kotlin","text":"You can add this in your configuration tag: <plugin> <groupId> org.jetbrains.kotlin </groupId> <artifactId> kotlin-maven-plugin </artifactId> <version> ${kotlin.version} </version> <executions> ... </executions> <configuration> <args> <!-- Add this --> <arg> -java-parameters </arg> ... </args> </configuration> </plugin>","title":"Kotlin"},{"location":"using-commands/Inferred-option-names/#adding-java-kotlin-parameters-for-gradle","text":"","title":"Adding Java &amp; Kotlin parameters for Gradle"},{"location":"using-commands/Inferred-option-names/#java_1","text":"You can add this in your build.gradle : compileJava { compilerArgs += '-parameters' }","title":"Java"},{"location":"using-commands/Inferred-option-names/#kotlin_1","text":"You can add this in your build.gradle : compileKotlin { kotlinOptions.javaParameters = true }","title":"Kotlin"},{"location":"using-commands/Prefixed-commands/","text":"Writing prefixed commands \u00b6 A few keywords \u00b6 TextCommand - The class which should be inherited by every (regex) prefixed command BContext - The BotCommands context, it can help you get the JDA instance, check if someone is a bot (co)owner, get the default embeds, add/remove filters and much more CommandEvent - The event object received when a command is used, it extends GuildMessageReceivedEvent and provides more functions to help parse the command arguments #hasNext(Class<T>) , #peekArgument(Class<T>) and #nextArgument(Class<T>) accepts classes such as strings and mentionables (user / member / text channel / role) #resolveNext(Class<?>...) tries to resolve mentionables either from the full mention or from just a given ID, throwing an exception if it is not resolvable @Hidden - Hides a command from help content and from being used by non-owners @RequireOwner - Makes a command usable only by bot (co)owners Making a prefixed command \u00b6 To make a valid prefixed command, you need to extend TextCommand and to have methods which are annotated with @JDATextCommand There's attributes that are inheritable - so you can place them on the class instead of the individual methods, such as: * Category * Description * Bot / User permission Regex based commands \u00b6 These commands have their method signature translated to a regex on runtime, it then converts the groups into your method parameters automatically Their parameters need to be annotated with @TextOption The commands can have a parsing order if you specify it in the command annotation Be aware: The order of the methods might be important, only the first method which matches the regex is run Changing the order of the methods at a source code level is not reliable, to fix this, specify the order value in the @JDATextCommand annotation on each method Strings are a common way of making these commands not work correctly, depending on how many there are and where they are placed in your parameters , the framework will throw at startup if a command is \"too complex\" Example: @CommandMarker //No unused warnings @Category ( \"Utils\" ) @Description ( \"Gives information about an entity\" ) public class Info extends TextCommand { //Specifying the order makes it so methods have priorities, this is useful in this command because TextChannel, Role and Guild might have the same ids // (example: @everyone, the first text channel created and the guild has the same id) @JDATextCommand ( name = \"info\" , order = 1 ) //Method to be checked first public void exec ( BaseCommandEvent event , @TextOption Member member ) { //@TextOption is mandatory on parameters that have to be parsed //Show member info } @JDATextCommand ( name = \"info\" , order = 2 ) public void exec ( BaseCommandEvent event , @TextOption User user ) { //Show user info } } Fallback commands \u00b6 If none of the regex patterns matched, if this method exists then it's going to get called, otherwise, help content is shown Example: @CommandMarker //No unused warnings @Category ( \"Utils\" ) @Description ( \"Gives the ping of the bot\" ) public class Ping extends TextCommand { @JDATextCommand ( name = \"ping\" ) public void exec ( CommandEvent event ) { //Fallback CommandEvent final long gatewayPing = event . getJDA (). getGatewayPing (); event . getJDA (). getRestPing () . queue ( l -> event . replyFormat ( \"Gateway ping: **%d ms**\\nRest ping: **%d ms**\" , gatewayPing , l ). queue ()); } } Adding alternative prefixes \u00b6 You can add alternative prefixes if you have a SettingsProvider such as: public class PrefixSettingsProvider implements SettingsProvider { @Override @Nullable public List < String > getPrefixes ( @NotNull Guild guild ) { if ( guild . getIdLong () == 722891685755093072L ) { return List . of ( \"^\" ); //Only the prefix \"^\" will be used for the guild ID above } return SettingsProvider . super . getPrefixes ( guild ); } } You can then register your SettingsProvider by adding #setSettingsProvider(new PrefixSettingsProvider()) to your CommandsBuilder chain Replacing help content \u00b6 You can replace the default help command by making a text command with the same path. Your help command needs to implement IHelpCommand so that the help is still displayed when commands are detected, but their syntax is invalid You can also not provide an help implementation and just disable the command with TextCommandsBuilder#disableHelpCommand You can also modify the help embeds with TextCommandsBuilder#setHelpBuilderConsumer","title":"Writing prefixed commands"},{"location":"using-commands/Prefixed-commands/#writing-prefixed-commands","text":"","title":"Writing prefixed commands"},{"location":"using-commands/Prefixed-commands/#a-few-keywords","text":"TextCommand - The class which should be inherited by every (regex) prefixed command BContext - The BotCommands context, it can help you get the JDA instance, check if someone is a bot (co)owner, get the default embeds, add/remove filters and much more CommandEvent - The event object received when a command is used, it extends GuildMessageReceivedEvent and provides more functions to help parse the command arguments #hasNext(Class<T>) , #peekArgument(Class<T>) and #nextArgument(Class<T>) accepts classes such as strings and mentionables (user / member / text channel / role) #resolveNext(Class<?>...) tries to resolve mentionables either from the full mention or from just a given ID, throwing an exception if it is not resolvable @Hidden - Hides a command from help content and from being used by non-owners @RequireOwner - Makes a command usable only by bot (co)owners","title":"A few keywords"},{"location":"using-commands/Prefixed-commands/#making-a-prefixed-command","text":"To make a valid prefixed command, you need to extend TextCommand and to have methods which are annotated with @JDATextCommand There's attributes that are inheritable - so you can place them on the class instead of the individual methods, such as: * Category * Description * Bot / User permission","title":"Making a prefixed command"},{"location":"using-commands/Prefixed-commands/#regex-based-commands","text":"These commands have their method signature translated to a regex on runtime, it then converts the groups into your method parameters automatically Their parameters need to be annotated with @TextOption The commands can have a parsing order if you specify it in the command annotation Be aware: The order of the methods might be important, only the first method which matches the regex is run Changing the order of the methods at a source code level is not reliable, to fix this, specify the order value in the @JDATextCommand annotation on each method Strings are a common way of making these commands not work correctly, depending on how many there are and where they are placed in your parameters , the framework will throw at startup if a command is \"too complex\" Example: @CommandMarker //No unused warnings @Category ( \"Utils\" ) @Description ( \"Gives information about an entity\" ) public class Info extends TextCommand { //Specifying the order makes it so methods have priorities, this is useful in this command because TextChannel, Role and Guild might have the same ids // (example: @everyone, the first text channel created and the guild has the same id) @JDATextCommand ( name = \"info\" , order = 1 ) //Method to be checked first public void exec ( BaseCommandEvent event , @TextOption Member member ) { //@TextOption is mandatory on parameters that have to be parsed //Show member info } @JDATextCommand ( name = \"info\" , order = 2 ) public void exec ( BaseCommandEvent event , @TextOption User user ) { //Show user info } }","title":"Regex based commands"},{"location":"using-commands/Prefixed-commands/#fallback-commands","text":"If none of the regex patterns matched, if this method exists then it's going to get called, otherwise, help content is shown Example: @CommandMarker //No unused warnings @Category ( \"Utils\" ) @Description ( \"Gives the ping of the bot\" ) public class Ping extends TextCommand { @JDATextCommand ( name = \"ping\" ) public void exec ( CommandEvent event ) { //Fallback CommandEvent final long gatewayPing = event . getJDA (). getGatewayPing (); event . getJDA (). getRestPing () . queue ( l -> event . replyFormat ( \"Gateway ping: **%d ms**\\nRest ping: **%d ms**\" , gatewayPing , l ). queue ()); } }","title":"Fallback commands"},{"location":"using-commands/Prefixed-commands/#adding-alternative-prefixes","text":"You can add alternative prefixes if you have a SettingsProvider such as: public class PrefixSettingsProvider implements SettingsProvider { @Override @Nullable public List < String > getPrefixes ( @NotNull Guild guild ) { if ( guild . getIdLong () == 722891685755093072L ) { return List . of ( \"^\" ); //Only the prefix \"^\" will be used for the guild ID above } return SettingsProvider . super . getPrefixes ( guild ); } } You can then register your SettingsProvider by adding #setSettingsProvider(new PrefixSettingsProvider()) to your CommandsBuilder chain","title":"Adding alternative prefixes"},{"location":"using-commands/Prefixed-commands/#replacing-help-content","text":"You can replace the default help command by making a text command with the same path. Your help command needs to implement IHelpCommand so that the help is still displayed when commands are detected, but their syntax is invalid You can also not provide an help implementation and just disable the command with TextCommandsBuilder#disableHelpCommand You can also modify the help embeds with TextCommandsBuilder#setHelpBuilderConsumer","title":"Replacing help content"},{"location":"using-commands/Using-localization/","text":"Using localization \u00b6 Localization lets you translate commands & responses to the user's or the guild's language, all languages supported by Discord are supported by the framework, you can find a list of languages in JDA's DiscordLocale . Localization files \u00b6 Localization can be stored in the JSON format and can contain your command translations, as well as command responses, or any other string. Where do I store them ? \u00b6 Localization files must be stored in the bc_localization folder, in your resources directory, these files can be of any base name, but must end with the locale's string, and must have a .json extension. Examples: Default localization for the MyLocalizations bundle: MyLocalizations.json English localization for the MyLocalizations bundle: MyLocalizations_en.json UK localization for the MyLocalizations bundle: MyLocalizations_en_GB.json What do they look like ? \u00b6 The JSON file is going to be an object, with each key being the \"localization key\" and the value being the \"localization template\". The localization key is a string where keywords are separated by a dot, the framework takes advantage of JSON as you can nest objects with their translations inside, the path to the nested translation will be your localization key, but they can look exactly like the keys in Java's ResourceBundle , where no nesting is required. Example without nesting { \"ban.name\" : \"ban\" , \"ban.description\" : \"Bans an user\" } Example with nesting { \"ban\" : { \"name\" : \"ban\" , \"description\" : \"Bans an user\" } } What are localization templates ? \u00b6 Localization templates are going to determine how your localized strings will include runtime values. The default localization templates works the same as Java's MessageFormat , except it accepts named arguments instead of indexes. In a nutshell, you can either have basic templates such as This message will delete itself in {deleteTime} seconds , or have complex templates which will accept the argument name, the format type and the format style. Example - /ban success message /resources/bc_localization/MyCommandsLocalization.json { \"ban.success\" : \"{bannedUser} was banned successfully for the reason '{reason}', and {delHours} {delHours, choice, 1#hour|2<hours} of messages were deleted\" } Don't forget @LocalizationBundle ( \"MyCommandsLocalization\" ) to use your localization bundle ! Ban.java final String response = event . localize ( \"ban.success\" , entry ( \"bannedUser\" , targetUser . getAsMention ()), entry ( \"delHours\" , delHours ), // (1) entry ( \"reason\" , reason ) ); event . reply ( response ). queue (); The hours of messages being deleted can use different wording depending on plurality, this is reflected on the localization templates with a choice format type, and a choice format Localizing default messages \u00b6 Default messages are messages that can be sent by the framework itself, they can come from the command listeners, components or modals for example. Replacing default messages \u00b6 Default messages are defined in /resources/bc_localization/DefaultMessages.json , this is where you can find all the localization keys used by the framework. To override one or more default messages, create your own DefaultMessages.json , like you would with a normal localization file. /resources/bc_localization/DefaultMessages.json { \"general_error_message\" : \"The bot has encountered an error, try again later.\" } Adding translations to default messages \u00b6 Default messages can also be localized, but they must keep the same base name, i.e. DefaultMessages . /resources/bc_localization/DefaultMessages_fr.json { \"general_error_message\" : \"Le bot a rencontr\u00e9 une erreur, veuillez r\u00e9essayer plus tard.\" } Localizing application commands \u00b6 Only application commands supports localization, translations can include names and description of commands as well as options, and also choice names. You will need to indicate to the framework which localization files are available, and which languages they support. This can be done with ApplicationCommandsBuilder#addLocalizations , such as: Main.java CommandsBuilder builder = ...; builder . applicationCommandBuilder ( applicationCommandsBuilder -> applicationCommandsBuilder . addLocalizations ( \"LocalizationWikiCommands\" , DiscordLocale . ENGLISH_US ) // (1) ); This enables localization from the LocalizationWikiCommands.json bundle, in the en_US language. (i.e. LocalizationWikiCommands_en_US.json ) If you wish to add more localizations, add a DiscordLocale here, and create the corresponding files. You can then create your commands as you would normally, no need to set up special names or anything. Your localization keys will be the same as specified by JDA's LocalizationFunction , which means the keys are composed of the complete path, combined with the option's name and the choice's name as well, please refer to the JDA documentation for more details. An example can be found here Inferred command and option descriptions \u00b6 Application command descriptions and option descriptions can be retrieved from the \"root\" localization bundles, i.e. localization bundles without a language specified, such as LocalizationWikiCommands.json Localizing responses \u00b6 Localizing responses can be done using the framework's events, with the localize methods and its overloads. The method uses the best locale available, depending on the context: Any type of Interaction : Uses the user's locale Other events: Uses the Guild's locale (US English by default) Let's say someone used a ban command, but the caller cannot ban the user, due to hierarchy reasons: SlashBan.java final String errorMessage = event . localize ( // (1) \"ban.caller.interact_error\" , entry ( \"mention\" , targetMember . getAsMention ()) // (2) ); event . reply ( errorMessage ). queue (); This will use the user's locale, as a slash command is an interaction. \"mention\" is a variable of the string template Example project \u00b6 You can also see this very small bot using localization: Link","title":"Using localization"},{"location":"using-commands/Using-localization/#using-localization","text":"Localization lets you translate commands & responses to the user's or the guild's language, all languages supported by Discord are supported by the framework, you can find a list of languages in JDA's DiscordLocale .","title":"Using localization"},{"location":"using-commands/Using-localization/#localization-files","text":"Localization can be stored in the JSON format and can contain your command translations, as well as command responses, or any other string.","title":"Localization files"},{"location":"using-commands/Using-localization/#where-do-i-store-them","text":"Localization files must be stored in the bc_localization folder, in your resources directory, these files can be of any base name, but must end with the locale's string, and must have a .json extension. Examples: Default localization for the MyLocalizations bundle: MyLocalizations.json English localization for the MyLocalizations bundle: MyLocalizations_en.json UK localization for the MyLocalizations bundle: MyLocalizations_en_GB.json","title":"Where do I store them ?"},{"location":"using-commands/Using-localization/#what-do-they-look-like","text":"The JSON file is going to be an object, with each key being the \"localization key\" and the value being the \"localization template\". The localization key is a string where keywords are separated by a dot, the framework takes advantage of JSON as you can nest objects with their translations inside, the path to the nested translation will be your localization key, but they can look exactly like the keys in Java's ResourceBundle , where no nesting is required. Example without nesting { \"ban.name\" : \"ban\" , \"ban.description\" : \"Bans an user\" } Example with nesting { \"ban\" : { \"name\" : \"ban\" , \"description\" : \"Bans an user\" } }","title":"What do they look like ?"},{"location":"using-commands/Using-localization/#what-are-localization-templates","text":"Localization templates are going to determine how your localized strings will include runtime values. The default localization templates works the same as Java's MessageFormat , except it accepts named arguments instead of indexes. In a nutshell, you can either have basic templates such as This message will delete itself in {deleteTime} seconds , or have complex templates which will accept the argument name, the format type and the format style. Example - /ban success message /resources/bc_localization/MyCommandsLocalization.json { \"ban.success\" : \"{bannedUser} was banned successfully for the reason '{reason}', and {delHours} {delHours, choice, 1#hour|2<hours} of messages were deleted\" } Don't forget @LocalizationBundle ( \"MyCommandsLocalization\" ) to use your localization bundle ! Ban.java final String response = event . localize ( \"ban.success\" , entry ( \"bannedUser\" , targetUser . getAsMention ()), entry ( \"delHours\" , delHours ), // (1) entry ( \"reason\" , reason ) ); event . reply ( response ). queue (); The hours of messages being deleted can use different wording depending on plurality, this is reflected on the localization templates with a choice format type, and a choice format","title":"What are localization templates ?"},{"location":"using-commands/Using-localization/#localizing-default-messages","text":"Default messages are messages that can be sent by the framework itself, they can come from the command listeners, components or modals for example.","title":"Localizing default messages"},{"location":"using-commands/Using-localization/#replacing-default-messages","text":"Default messages are defined in /resources/bc_localization/DefaultMessages.json , this is where you can find all the localization keys used by the framework. To override one or more default messages, create your own DefaultMessages.json , like you would with a normal localization file. /resources/bc_localization/DefaultMessages.json { \"general_error_message\" : \"The bot has encountered an error, try again later.\" }","title":"Replacing default messages"},{"location":"using-commands/Using-localization/#adding-translations-to-default-messages","text":"Default messages can also be localized, but they must keep the same base name, i.e. DefaultMessages . /resources/bc_localization/DefaultMessages_fr.json { \"general_error_message\" : \"Le bot a rencontr\u00e9 une erreur, veuillez r\u00e9essayer plus tard.\" }","title":"Adding translations to default messages"},{"location":"using-commands/Using-localization/#localizing-application-commands","text":"Only application commands supports localization, translations can include names and description of commands as well as options, and also choice names. You will need to indicate to the framework which localization files are available, and which languages they support. This can be done with ApplicationCommandsBuilder#addLocalizations , such as: Main.java CommandsBuilder builder = ...; builder . applicationCommandBuilder ( applicationCommandsBuilder -> applicationCommandsBuilder . addLocalizations ( \"LocalizationWikiCommands\" , DiscordLocale . ENGLISH_US ) // (1) ); This enables localization from the LocalizationWikiCommands.json bundle, in the en_US language. (i.e. LocalizationWikiCommands_en_US.json ) If you wish to add more localizations, add a DiscordLocale here, and create the corresponding files. You can then create your commands as you would normally, no need to set up special names or anything. Your localization keys will be the same as specified by JDA's LocalizationFunction , which means the keys are composed of the complete path, combined with the option's name and the choice's name as well, please refer to the JDA documentation for more details. An example can be found here","title":"Localizing application commands"},{"location":"using-commands/Using-localization/#inferred-command-and-option-descriptions","text":"Application command descriptions and option descriptions can be retrieved from the \"root\" localization bundles, i.e. localization bundles without a language specified, such as LocalizationWikiCommands.json","title":"Inferred command and option descriptions"},{"location":"using-commands/Using-localization/#localizing-responses","text":"Localizing responses can be done using the framework's events, with the localize methods and its overloads. The method uses the best locale available, depending on the context: Any type of Interaction : Uses the user's locale Other events: Uses the Guild's locale (US English by default) Let's say someone used a ban command, but the caller cannot ban the user, due to hierarchy reasons: SlashBan.java final String errorMessage = event . localize ( // (1) \"ban.caller.interact_error\" , entry ( \"mention\" , targetMember . getAsMention ()) // (2) ); event . reply ( errorMessage ). queue (); This will use the user's locale, as a slash command is an interaction. \"mention\" is a variable of the string template","title":"Localizing responses"},{"location":"using-commands/Using-localization/#example-project","text":"You can also see this very small bot using localization: Link","title":"Example project"},{"location":"using-commands/updating-application-commands/Slash-commands---Updating-option-choices/","text":"Slash commands - Updating option choices \u00b6 See here the example on how to add predefined choices to your slash commands You can also change the GuildApplicationSettings#getOptionChoices to provide dynamic values, for example if you have a command that adds choices, you would add the choice to the list and then call BContext#scheduleApplicationCommandsUpdate to update the application commands with the new choices Example - How to make a dynamic choice list, having a command to add choices public class SlashChoices extends ApplicationCommand { private static final Logger LOGGER = Logging . getLogger (); private final List < Command . Choice > valueList = new ArrayList <> (); @Override @NotNull public List < Command . Choice > getOptionChoices ( @Nullable Guild guild , @NotNull CommandPath commandPath , int optionIndex ) { if ( optionIndex == 0 ) { return valueList ; } return List . of (); } @JDASlashCommand ( name = \"choices\" , subcommand = \"choose\" ) public void choose ( GuildSlashEvent event , @AppOption ( description = \"The value you choose\" ) String value ) { event . reply ( \"Your choice: \" + value ) . setEphemeral ( true ) . queue (); } @JDASlashCommand ( name = \"choices\" , subcommand = \"add\" ) public void addChoice ( GuildSlashEvent event , @AppOption ( description = \"The name of the choice\" ) String name , @AppOption ( description = \"The value of the choice\" ) String value ) { event . deferReply ( true ). queue (); valueList . add ( new Command . Choice ( name , value )); //You should handle the exceptions inside the completable future, in case an error occurred event . getContext (). scheduleApplicationCommandsUpdate ( event . getGuild (), false , false ); event . getHook (). sendMessage ( \"Choice added successfully\" ). queue (); } }","title":"Slash commands - Updating option choices"},{"location":"using-commands/updating-application-commands/Slash-commands---Updating-option-choices/#slash-commands-updating-option-choices","text":"See here the example on how to add predefined choices to your slash commands You can also change the GuildApplicationSettings#getOptionChoices to provide dynamic values, for example if you have a command that adds choices, you would add the choice to the list and then call BContext#scheduleApplicationCommandsUpdate to update the application commands with the new choices Example - How to make a dynamic choice list, having a command to add choices public class SlashChoices extends ApplicationCommand { private static final Logger LOGGER = Logging . getLogger (); private final List < Command . Choice > valueList = new ArrayList <> (); @Override @NotNull public List < Command . Choice > getOptionChoices ( @Nullable Guild guild , @NotNull CommandPath commandPath , int optionIndex ) { if ( optionIndex == 0 ) { return valueList ; } return List . of (); } @JDASlashCommand ( name = \"choices\" , subcommand = \"choose\" ) public void choose ( GuildSlashEvent event , @AppOption ( description = \"The value you choose\" ) String value ) { event . reply ( \"Your choice: \" + value ) . setEphemeral ( true ) . queue (); } @JDASlashCommand ( name = \"choices\" , subcommand = \"add\" ) public void addChoice ( GuildSlashEvent event , @AppOption ( description = \"The name of the choice\" ) String name , @AppOption ( description = \"The value of the choice\" ) String value ) { event . deferReply ( true ). queue (); valueList . add ( new Command . Choice ( name , value )); //You should handle the exceptions inside the completable future, in case an error occurred event . getContext (). scheduleApplicationCommandsUpdate ( event . getGuild (), false , false ); event . getHook (). sendMessage ( \"Choice added successfully\" ). queue (); } }","title":"Slash commands - Updating option choices"},{"location":"using-commands/using-slash-commands/Managing-application-commands/","text":"Adding or removing application commands from certain Guilds \u00b6 You can specify which application commands are available on a per-guild basis by using a SettingsProvider You do need to set the SettingsProvider with CommandsBuilder#setSettingsProvider Suppose you have a slash command /info : The /info command public class SlashInfo extends ApplicationCommand { @JDASlashCommand ( name = \"info\" , subcommand = \"user\" ) public void userInfo ( GuildSlashEvent event , @AppOption User user ) { event . reply ( \"User: \" + user ). queue (); } @JDASlashCommand ( name = \"info\" , subcommand = \"channel\" ) public void channelInfo ( GuildSlashEvent event , @AppOption TextChannel channel ) { event . reply ( \"Channel: \" + channel ). queue (); } @JDASlashCommand ( name = \"info\" , subcommand = \"role\" ) public void roleInfo ( GuildSlashEvent event , @AppOption Role role ) { event . reply ( \"Role: \" + role ). queue (); } } You then want this command to be disabled by default in every guild (so require a later manual activation by Guild moderators for example): The BasicSettingsProvider class public class BasicSettingsProvider implements SettingsProvider { private static final Logger LOGGER = Logging . getLogger (); private final Map < Long , List < String >> disabledCommandsMap = new HashMap <> (); private final BContext context ; public BasicSettingsProvider ( BContext context ) { this . context = context ; } @Override @NotNull public CommandList getGuildCommands ( @NotNull Guild guild ) { return CommandList . notOf ( getBlacklist ( guild )); } @NotNull private List < String > getBlacklist ( Guild guild ) { //Blacklist filter - the ArrayList is created only if the guild's ID was not already in the map. return disabledCommandsMap . computeIfAbsent ( guild . getIdLong (), x -> { final ArrayList < String > disabledCommands = new ArrayList <> (); //Let's say the info command is disabled by default disabledCommands . add ( \"info\" ); return disabledCommands ; }); } //This is for the part where you want to update the command list later // So you can use this method to \"enable\" an application command for a guild // For example in a text command public void addCommand ( Guild guild , String commandName ) { getBlacklist ( guild ). remove ( commandName ); //Removes the command from the blacklist //You should handle the exceptions inside the completable future, in case an error occurred context . scheduleApplicationCommandsUpdate ( guild , false , false ); } } You can then simply set the SettingsProvider in CommandsBuilder : How to set the settings provider var builder = CommandsBuilder . withPrefix (...) builder . setSettingsProvider ( new BasicSettingsProvider ( builder . getContext ())) ... . build (...);","title":"Managing guild application commands"},{"location":"using-commands/using-slash-commands/Managing-application-commands/#adding-or-removing-application-commands-from-certain-guilds","text":"You can specify which application commands are available on a per-guild basis by using a SettingsProvider You do need to set the SettingsProvider with CommandsBuilder#setSettingsProvider Suppose you have a slash command /info : The /info command public class SlashInfo extends ApplicationCommand { @JDASlashCommand ( name = \"info\" , subcommand = \"user\" ) public void userInfo ( GuildSlashEvent event , @AppOption User user ) { event . reply ( \"User: \" + user ). queue (); } @JDASlashCommand ( name = \"info\" , subcommand = \"channel\" ) public void channelInfo ( GuildSlashEvent event , @AppOption TextChannel channel ) { event . reply ( \"Channel: \" + channel ). queue (); } @JDASlashCommand ( name = \"info\" , subcommand = \"role\" ) public void roleInfo ( GuildSlashEvent event , @AppOption Role role ) { event . reply ( \"Role: \" + role ). queue (); } } You then want this command to be disabled by default in every guild (so require a later manual activation by Guild moderators for example): The BasicSettingsProvider class public class BasicSettingsProvider implements SettingsProvider { private static final Logger LOGGER = Logging . getLogger (); private final Map < Long , List < String >> disabledCommandsMap = new HashMap <> (); private final BContext context ; public BasicSettingsProvider ( BContext context ) { this . context = context ; } @Override @NotNull public CommandList getGuildCommands ( @NotNull Guild guild ) { return CommandList . notOf ( getBlacklist ( guild )); } @NotNull private List < String > getBlacklist ( Guild guild ) { //Blacklist filter - the ArrayList is created only if the guild's ID was not already in the map. return disabledCommandsMap . computeIfAbsent ( guild . getIdLong (), x -> { final ArrayList < String > disabledCommands = new ArrayList <> (); //Let's say the info command is disabled by default disabledCommands . add ( \"info\" ); return disabledCommands ; }); } //This is for the part where you want to update the command list later // So you can use this method to \"enable\" an application command for a guild // For example in a text command public void addCommand ( Guild guild , String commandName ) { getBlacklist ( guild ). remove ( commandName ); //Removes the command from the blacklist //You should handle the exceptions inside the completable future, in case an error occurred context . scheduleApplicationCommandsUpdate ( guild , false , false ); } } You can then simply set the SettingsProvider in CommandsBuilder : How to set the settings provider var builder = CommandsBuilder . withPrefix (...) builder . setSettingsProvider ( new BasicSettingsProvider ( builder . getContext ())) ... . build (...);","title":"Adding or removing application commands from certain Guilds"},{"location":"using-commands/using-slash-commands/Slash-commands/","text":"Writing slash commands \u00b6 Slash commands are the new way of defining commands, even though there are limitations with them, we do have some advantages such as auto-completion and much easier parsing - things that regular commands can't do reliably A few keywords \u00b6 ApplicationCommand - Must be extended by the class which contains applications commands @AppOption - Mandatory on options, also allows you to set the option name and description, by default the name is the parameter name (of the method) and description is No description @JDASlashCommand - Annotation for methods which marks slash commands Making a slash command \u00b6 A slash command is similar to a regex prefixed command - You extend ApplicationCommand on your class and use @JDASlashCommand on every method you want to be a slash command Your method has to: Be public Have GuildSlashEvent (for guild-only slash commands, if not specified explicitly, a slash command is guild-only) as first parameter, or a GlobalSlashEvent for global commands Be annotated @JDASlashCommand Examples \u00b6 Basic /ping command public class SlashPing extends ApplicationCommand { @JDASlashCommand ( scope = CommandScope . GLOBAL , name = \"ping\" , description = \"Pong !\" ) public void onPing ( GlobalSlashEvent event ) { event . deferReply (). queue (); final long gatewayPing = event . getJDA (). getGatewayPing (); event . getJDA (). getRestPing () . queue ( l -> event . getHook () . sendMessageFormat ( \"Gateway ping: **%d ms**\\nRest ping: **%d ms**\" , gatewayPing , l ) . queue ()); } } Example with choices public class SlashSay extends ApplicationCommand { // If the method is placed in the same file then it is guaranteed to be only the \"say\" command path, // so it won't interfere with other commands @Override @NotNull public List < Command . Choice > getOptionChoices ( @Nullable Guild guild , @NotNull CommandPath commandPath , int optionIndex ) { if ( optionIndex == 0 ) { //First option return List . of ( //Only choices here are \"Hi\" and \"Hello\" and gets \"translated\" to their respective values new Command . Choice ( \"Hi\" , \"Greetings, comrad\" ), new Command . Choice ( \"Hello\" , \"Oy\" ) ); } return List . of (); } @JDASlashCommand ( //This command is guild-only by default name = \"say\" , description = \"Says what you type\" ) public void say ( GuildSlashEvent event , //Option name is by default the parameter name @AppOption ( description = \"What you want to say\" ) String text ) { event . reply ( \"Your choice: \" + text ). queue (); } }","title":"Writing slash commands"},{"location":"using-commands/using-slash-commands/Slash-commands/#writing-slash-commands","text":"Slash commands are the new way of defining commands, even though there are limitations with them, we do have some advantages such as auto-completion and much easier parsing - things that regular commands can't do reliably","title":"Writing slash commands"},{"location":"using-commands/using-slash-commands/Slash-commands/#a-few-keywords","text":"ApplicationCommand - Must be extended by the class which contains applications commands @AppOption - Mandatory on options, also allows you to set the option name and description, by default the name is the parameter name (of the method) and description is No description @JDASlashCommand - Annotation for methods which marks slash commands","title":"A few keywords"},{"location":"using-commands/using-slash-commands/Slash-commands/#making-a-slash-command","text":"A slash command is similar to a regex prefixed command - You extend ApplicationCommand on your class and use @JDASlashCommand on every method you want to be a slash command Your method has to: Be public Have GuildSlashEvent (for guild-only slash commands, if not specified explicitly, a slash command is guild-only) as first parameter, or a GlobalSlashEvent for global commands Be annotated @JDASlashCommand","title":"Making a slash command"},{"location":"using-commands/using-slash-commands/Slash-commands/#examples","text":"Basic /ping command public class SlashPing extends ApplicationCommand { @JDASlashCommand ( scope = CommandScope . GLOBAL , name = \"ping\" , description = \"Pong !\" ) public void onPing ( GlobalSlashEvent event ) { event . deferReply (). queue (); final long gatewayPing = event . getJDA (). getGatewayPing (); event . getJDA (). getRestPing () . queue ( l -> event . getHook () . sendMessageFormat ( \"Gateway ping: **%d ms**\\nRest ping: **%d ms**\" , gatewayPing , l ) . queue ()); } } Example with choices public class SlashSay extends ApplicationCommand { // If the method is placed in the same file then it is guaranteed to be only the \"say\" command path, // so it won't interfere with other commands @Override @NotNull public List < Command . Choice > getOptionChoices ( @Nullable Guild guild , @NotNull CommandPath commandPath , int optionIndex ) { if ( optionIndex == 0 ) { //First option return List . of ( //Only choices here are \"Hi\" and \"Hello\" and gets \"translated\" to their respective values new Command . Choice ( \"Hi\" , \"Greetings, comrad\" ), new Command . Choice ( \"Hello\" , \"Oy\" ) ); } return List . of (); } @JDASlashCommand ( //This command is guild-only by default name = \"say\" , description = \"Says what you type\" ) public void say ( GuildSlashEvent event , //Option name is by default the parameter name @AppOption ( description = \"What you want to say\" ) String text ) { event . reply ( \"Your choice: \" + text ). queue (); } }","title":"Examples"},{"location":"using-commands/using-slash-commands/Updating-slash-commands/","text":"Updating existing commands on the fly \u00b6 Let's say a Guild moderator decides to enable the /info command in his Guild, you would need to take your BasicSettingsProvider (from BContext#getSettingsProvider ), cast it to your class and then use a method to remove the command from the Guild's blacklist, then finally call BContext#scheduleApplicationCommandsUpdate to update the commands and the slash commands local cache How to enable back the command and update the slash commands list - Using a regular command @Category ( \"Moderation\" ) @UserPermissions ( Permission . MANAGE_ROLES ) public class EnableInfoCommand extends TextCommand { @JDATextCommand ( name = \"enableinfocommand\" , description = \"Enables the /info command\" ) public void execute ( CommandEvent event ) { if ( event . getMember (). canInteract ( event . getGuild (). getSelfMember ())) { final BasicSettingsProvider settingsProvider = ( BasicSettingsProvider ) event . getContext (). getSettingsProvider (); if ( settingsProvider == null ) { event . indicateError ( \"No settings provider has been set\" ). queue (); return ; } settingsProvider . addCommand ( event . getGuild (), \"info\" ); event . reactSuccess (). queue (); } else { event . indicateError ( \"You cannot do this\" ). queue (); } } }","title":"Updating application commands"},{"location":"using-commands/using-slash-commands/Updating-slash-commands/#updating-existing-commands-on-the-fly","text":"Let's say a Guild moderator decides to enable the /info command in his Guild, you would need to take your BasicSettingsProvider (from BContext#getSettingsProvider ), cast it to your class and then use a method to remove the command from the Guild's blacklist, then finally call BContext#scheduleApplicationCommandsUpdate to update the commands and the slash commands local cache How to enable back the command and update the slash commands list - Using a regular command @Category ( \"Moderation\" ) @UserPermissions ( Permission . MANAGE_ROLES ) public class EnableInfoCommand extends TextCommand { @JDATextCommand ( name = \"enableinfocommand\" , description = \"Enables the /info command\" ) public void execute ( CommandEvent event ) { if ( event . getMember (). canInteract ( event . getGuild (). getSelfMember ())) { final BasicSettingsProvider settingsProvider = ( BasicSettingsProvider ) event . getContext (). getSettingsProvider (); if ( settingsProvider == null ) { event . indicateError ( \"No settings provider has been set\" ). queue (); return ; } settingsProvider . addCommand ( event . getGuild (), \"info\" ); event . reactSuccess (). queue (); } else { event . indicateError ( \"You cannot do this\" ). queue (); } } }","title":"Updating existing commands on the fly"},{"location":"using-components/Buttons/","text":"About buttons \u00b6 How can I use them ? \u00b6 You'll first need to have some experience using JDA's buttons directly You will need to have your ComponentManager set up in order to use the Components API, which is where the buttons are created. You can then use the Components class methods such as Components#primaryButton , which is equivalent to JDA's Button#primary , except it will give you a builder class where you can set the properties defined in the Components API wiki How to listen to button clicks \u00b6 You have to make a method annotated with @JDAButtonListener and have their first parameter be a ButtonEvent Example: @JDAButtonListener ( name = \"test\" ) public void testButtonListener ( ButtonEvent event ) { event . reply ( \"test\" ). setEphemeral ( true ). queue (); } More examples \u00b6 You can see more examples in the examples directory","title":"Buttons"},{"location":"using-components/Buttons/#about-buttons","text":"","title":"About buttons"},{"location":"using-components/Buttons/#how-can-i-use-them","text":"You'll first need to have some experience using JDA's buttons directly You will need to have your ComponentManager set up in order to use the Components API, which is where the buttons are created. You can then use the Components class methods such as Components#primaryButton , which is equivalent to JDA's Button#primary , except it will give you a builder class where you can set the properties defined in the Components API wiki","title":"How can I use them ?"},{"location":"using-components/Buttons/#how-to-listen-to-button-clicks","text":"You have to make a method annotated with @JDAButtonListener and have their first parameter be a ButtonEvent Example: @JDAButtonListener ( name = \"test\" ) public void testButtonListener ( ButtonEvent event ) { event . reply ( \"test\" ). setEphemeral ( true ). queue (); }","title":"How to listen to button clicks"},{"location":"using-components/Buttons/#more-examples","text":"You can see more examples in the examples directory","title":"More examples"},{"location":"using-components/Selection-menus/","text":"About selection menus \u00b6 Select menus can be of 2 types: string select menus, and, entity select menus. You can read more about them on JDA's wiki . How can I use them ? \u00b6 Prerequisites \u00b6 You will need to setup the ComponentManager first, in order to use these components. You can set it up here Creating selection menu \u00b6 The Components class lets you create selection menus with Components.stringSelectionMenu , and Components.entitySelectionMenu . How to create string select menus final StringSelectMenu selectMenu = Components . stringSelectionMenu ( ROLEPLAY_LABEL_SELECT_MENU_LISTENER , // Name of the listener, it is a constant in the class ThreadLocalRandom . current (). nextLong () // A random number we'll pass to the listener, for demonstration ) . oneUse () // (1) . setPlaceholder ( \"Choose a roleplay label\" ) . addOption ( \"Option 1\" , \"Label 1\" ) . addOption ( \"Option 2\" , \"Label 2\" ) . addOption ( \"Option 3\" , \"Label 3\" ) . build (); event . replyComponents ( ActionRow . of ( selectMenu )). queue (); This makes the select menu usable only once, but keep in mind that the framework won't delete it from the message. Warning The methods from the framework (such as oneUse or onTimeout ) needs to be used first. You can then use JDA's methods. Handling selection events \u00b6 You have to make a method annotated with @JDASelectionMenuListener and have their first parameter be a StringSelectionEvent , or a EntitySelectionEvent , depending on what component you are using. Example: SlashRoleplay.java private static final String ROLEPLAY_LABEL_SELECT_MENU_LISTENER = \"SlashRoleplay: roleplayLabelSelectMenu\" private static final String AUTO_ROLE_SELECT_MENU_LISTENER = \"SlashRoleplay: autoRoleSelectMenu\" @JDASelectionMenuListener ( name = ROLEPLAY_LABEL_SELECT_MENU_LISTENER ) public void onRoleplayLabelSelected ( StringSelectionEvent event , @AppOption long randomNumber ) { // Number we got back from when we created the selection menu event . replyFormat ( \"My random number is %d and your labels have been set to: %s\" , randomNumber , event . getValues ()) . setEphemeral ( true ) . queue (); } //If you were to create an entity select menu @JDASelectionMenuListener ( name = AUTO_ROLE_SELECT_MENU_LISTENER ) public void onAutoRoleSelected ( EntitySelectionEvent event ) { final String rolesString = event . getValues (). stream () . map ( IMentionable :: getAsMention ) . collect ( Collectors . joining ( \", \" )); event . reply ( \"Your roles have been set: \" + rolesString ). setEphemeral ( true ). queue (); } More examples \u00b6 You can see more examples in the examples directory","title":"Selection menus"},{"location":"using-components/Selection-menus/#about-selection-menus","text":"Select menus can be of 2 types: string select menus, and, entity select menus. You can read more about them on JDA's wiki .","title":"About selection menus"},{"location":"using-components/Selection-menus/#how-can-i-use-them","text":"","title":"How can I use them ?"},{"location":"using-components/Selection-menus/#prerequisites","text":"You will need to setup the ComponentManager first, in order to use these components. You can set it up here","title":"Prerequisites"},{"location":"using-components/Selection-menus/#creating-selection-menu","text":"The Components class lets you create selection menus with Components.stringSelectionMenu , and Components.entitySelectionMenu . How to create string select menus final StringSelectMenu selectMenu = Components . stringSelectionMenu ( ROLEPLAY_LABEL_SELECT_MENU_LISTENER , // Name of the listener, it is a constant in the class ThreadLocalRandom . current (). nextLong () // A random number we'll pass to the listener, for demonstration ) . oneUse () // (1) . setPlaceholder ( \"Choose a roleplay label\" ) . addOption ( \"Option 1\" , \"Label 1\" ) . addOption ( \"Option 2\" , \"Label 2\" ) . addOption ( \"Option 3\" , \"Label 3\" ) . build (); event . replyComponents ( ActionRow . of ( selectMenu )). queue (); This makes the select menu usable only once, but keep in mind that the framework won't delete it from the message. Warning The methods from the framework (such as oneUse or onTimeout ) needs to be used first. You can then use JDA's methods.","title":"Creating selection menu"},{"location":"using-components/Selection-menus/#handling-selection-events","text":"You have to make a method annotated with @JDASelectionMenuListener and have their first parameter be a StringSelectionEvent , or a EntitySelectionEvent , depending on what component you are using. Example: SlashRoleplay.java private static final String ROLEPLAY_LABEL_SELECT_MENU_LISTENER = \"SlashRoleplay: roleplayLabelSelectMenu\" private static final String AUTO_ROLE_SELECT_MENU_LISTENER = \"SlashRoleplay: autoRoleSelectMenu\" @JDASelectionMenuListener ( name = ROLEPLAY_LABEL_SELECT_MENU_LISTENER ) public void onRoleplayLabelSelected ( StringSelectionEvent event , @AppOption long randomNumber ) { // Number we got back from when we created the selection menu event . replyFormat ( \"My random number is %d and your labels have been set to: %s\" , randomNumber , event . getValues ()) . setEphemeral ( true ) . queue (); } //If you were to create an entity select menu @JDASelectionMenuListener ( name = AUTO_ROLE_SELECT_MENU_LISTENER ) public void onAutoRoleSelected ( EntitySelectionEvent event ) { final String rolesString = event . getValues (). stream () . map ( IMentionable :: getAsMention ) . collect ( Collectors . joining ( \", \" )); event . reply ( \"Your roles have been set: \" + rolesString ). setEphemeral ( true ). queue (); }","title":"Handling selection events"},{"location":"using-components/Selection-menus/#more-examples","text":"You can see more examples in the examples directory","title":"More examples"},{"location":"using-components/The-Components-API/","text":"The Components API \u00b6 The Components class is the only class you need to directly use when using components (buttons / selection menus), it provides a builder for every component in order to not introduce boilerplate such as Button . primary ( getId (...), \"Test button\" ); , it would instead be Components . primaryButton (...). build ( \"Test button\" ); Prerequisites \u00b6 You will need to set a ComponentManager in CommandsBuilder#setComponentManager , I strongly recommend that you use the DefaultComponentManager , unless you want to reimplement the interface. For the default component manager, you will need a database, you will not be able to use any database if you choose to use the DefaultComponentManager , PostgreSQL is what I tested the framework on, but MariaDB or H2 should work. The database does not need to be populated with anything , the tables are created on startup, you will only need to provide a Connection supplier. I also highly recommend you use a library capable of pooling SQL connections such as HikariCP , which will greatly reduce the time to process interactions / components Discord components features \u00b6 There are two types of components: Persistent components: These are used when you may need to run a method even after your bot is restarted Lambda components: These are used when you need a command's context (such as captured variables) using lambdas, however this does not survive bot restarts Both types supports properties such as: One-use-ness (Component is deleted from the component manager when all conditions are met and the linked code is executed) Interaction constraints (Component is only usable by users which meets any of the predefined filters) Timeouts (Component is deleted from the component manager after a period of time)","title":"The Components API"},{"location":"using-components/The-Components-API/#the-components-api","text":"The Components class is the only class you need to directly use when using components (buttons / selection menus), it provides a builder for every component in order to not introduce boilerplate such as Button . primary ( getId (...), \"Test button\" ); , it would instead be Components . primaryButton (...). build ( \"Test button\" );","title":"The Components API"},{"location":"using-components/The-Components-API/#prerequisites","text":"You will need to set a ComponentManager in CommandsBuilder#setComponentManager , I strongly recommend that you use the DefaultComponentManager , unless you want to reimplement the interface. For the default component manager, you will need a database, you will not be able to use any database if you choose to use the DefaultComponentManager , PostgreSQL is what I tested the framework on, but MariaDB or H2 should work. The database does not need to be populated with anything , the tables are created on startup, you will only need to provide a Connection supplier. I also highly recommend you use a library capable of pooling SQL connections such as HikariCP , which will greatly reduce the time to process interactions / components","title":"Prerequisites"},{"location":"using-components/The-Components-API/#discord-components-features","text":"There are two types of components: Persistent components: These are used when you may need to run a method even after your bot is restarted Lambda components: These are used when you need a command's context (such as captured variables) using lambdas, however this does not survive bot restarts Both types supports properties such as: One-use-ness (Component is deleted from the component manager when all conditions are met and the linked code is executed) Interaction constraints (Component is only usable by users which meets any of the predefined filters) Timeouts (Component is deleted from the component manager after a period of time)","title":"Discord components features"},{"location":"writing-extensions/Constructor-injection/","text":"You might have a use case where your command needs specific objects from other instances (such as a database connection perhaps), normally you could pass them to your command constructors, but here your commands are constructed automatically, so manually doing it is not an option. That's why you can register constructor parameter suppliers and also instance suppliers How to use them \u00b6 Let's suppose you have a slash command class which looks like this: public class SlashCtorInjectionTest extends ApplicationCommand { private final BContext context ; private final Connection connection ; public SlashCtorInjectionTest ( BContext context , Connection connection ) { this . context = context ; this . connection = connection ; } @JDASlashCommand ( name = \"ctorinj\" ) public void run ( GuildSlashEvent event ) { event . replyFormat ( \"My fields are %s and %s\" , context , connection ). queue (); } } You can make these types of constructors possible by using either of the two methods described above: Using an instance supplier: Connection connection = null ; //Just a test value CommandsBuilder . newBuilder ( 0 L ) . extensionsBuilder ( extensionsBuilder -> extensionsBuilder . registerInstanceSupplier ( SlashCtorInjectionTest . class , context -> new SlashCtorInjectionTest ( context , connection )) ) . build ( jda , \"com.freya02.bot.wiki.ctorinj.commands\" ); Or using a constructor parameter supplier (preferred): Connection connection = null ; //Just a test value CommandsBuilder . newBuilder ( 0 L ) . extensionsBuilder ( extensionsBuilder -> extensionsBuilder . registerConstructorParameter ( Connection . class , ignored -> connection ) ) . build ( jda , \"com.freya02.bot.wiki.ctorinj.commands\" ); Notes \u00b6 The constructor parameters can be in any order The constructor must be accessible (public)","title":"Constructor injection"},{"location":"writing-extensions/Constructor-injection/#how-to-use-them","text":"Let's suppose you have a slash command class which looks like this: public class SlashCtorInjectionTest extends ApplicationCommand { private final BContext context ; private final Connection connection ; public SlashCtorInjectionTest ( BContext context , Connection connection ) { this . context = context ; this . connection = connection ; } @JDASlashCommand ( name = \"ctorinj\" ) public void run ( GuildSlashEvent event ) { event . replyFormat ( \"My fields are %s and %s\" , context , connection ). queue (); } } You can make these types of constructors possible by using either of the two methods described above: Using an instance supplier: Connection connection = null ; //Just a test value CommandsBuilder . newBuilder ( 0 L ) . extensionsBuilder ( extensionsBuilder -> extensionsBuilder . registerInstanceSupplier ( SlashCtorInjectionTest . class , context -> new SlashCtorInjectionTest ( context , connection )) ) . build ( jda , \"com.freya02.bot.wiki.ctorinj.commands\" ); Or using a constructor parameter supplier (preferred): Connection connection = null ; //Just a test value CommandsBuilder . newBuilder ( 0 L ) . extensionsBuilder ( extensionsBuilder -> extensionsBuilder . registerConstructorParameter ( Connection . class , ignored -> connection ) ) . build ( jda , \"com.freya02.bot.wiki.ctorinj.commands\" );","title":"How to use them"},{"location":"writing-extensions/Constructor-injection/#notes","text":"The constructor parameters can be in any order The constructor must be accessible (public)","title":"Notes"},{"location":"writing-extensions/Creating-parameter-resolvers/","text":"The reason why your commands with method signatures like public void kick ( GuildSlashEvent event , @AppOption User user , @AppOption String reason ) works is because there are default parameter resolvers, the default resolvers are registered automatically when ParameterResolvers is loaded. They can resolve regex command parameters / application command parameters and also button parameters Creating a new ParameterResolver \u00b6 To create a new parameter resolver, you have the following steps: Create a new class Make it extend ParameterResolver Use the super constructor to indicate the type of the resolved object Implement one or more of these interfaces described in ParameterResolver Register the resolver with ExtensionsBuilder#registerParameterResolver Example - How to add a ParameterResolver \u00b6 //Create the resolver public class TimestampResolver extends ParameterResolver implements SlashParameterResolver { public TimestampResolver () { super ( Timestamp . class ); } @Override public Object resolve ( @NotNull BContext context , @NotNull SlashCommandInfo info , @NotNull CommandInteractionPayload event , @NotNull OptionMapping optionMapping ) { final Matcher timestampMatcher = MARKDOWN . matcher ( optionMapping . getAsString ()); if ( ! timestampMatcher . find ()) return null ; //Avoid expensive exceptions from JDA final String format = timestampMatcher . group ( \"style\" ); final long time = Long . parseLong ( timestampMatcher . group ( \"time\" )); return ( format == null ? DEFAULT : fromStyle ( format )). atTimestamp ( time ); } @Override @NotNull public OptionType getOptionType () { return OptionType . STRING ; } } Registering the parameter resolver \u00b6 CommandsBuilder . newBuilder () . extensionsBuilder ( extensionsBuilder -> extensionsBuilder . registerParameterResolver ( new TimestampResolver ()) ) . build ( jda , \"com.freya02.bot.wiki.paramresolver.commands\" ); Using these parameters \u00b6 public class SlashParamResolverTest extends ApplicationCommand { @JDASlashCommand ( name = \"paramres\" ) public void run ( GuildSlashEvent event , @AppOption Timestamp timestamp ) { event . reply ( \"Your timestamp as relative: \" + TimeFormat . RELATIVE . format ( timestamp . getTimestamp ())). queue (); } }","title":"Creating parameter resolvers"},{"location":"writing-extensions/Creating-parameter-resolvers/#creating-a-new-parameterresolver","text":"To create a new parameter resolver, you have the following steps: Create a new class Make it extend ParameterResolver Use the super constructor to indicate the type of the resolved object Implement one or more of these interfaces described in ParameterResolver Register the resolver with ExtensionsBuilder#registerParameterResolver","title":"Creating a new ParameterResolver"},{"location":"writing-extensions/Creating-parameter-resolvers/#example-how-to-add-a-parameterresolver","text":"//Create the resolver public class TimestampResolver extends ParameterResolver implements SlashParameterResolver { public TimestampResolver () { super ( Timestamp . class ); } @Override public Object resolve ( @NotNull BContext context , @NotNull SlashCommandInfo info , @NotNull CommandInteractionPayload event , @NotNull OptionMapping optionMapping ) { final Matcher timestampMatcher = MARKDOWN . matcher ( optionMapping . getAsString ()); if ( ! timestampMatcher . find ()) return null ; //Avoid expensive exceptions from JDA final String format = timestampMatcher . group ( \"style\" ); final long time = Long . parseLong ( timestampMatcher . group ( \"time\" )); return ( format == null ? DEFAULT : fromStyle ( format )). atTimestamp ( time ); } @Override @NotNull public OptionType getOptionType () { return OptionType . STRING ; } }","title":"Example - How to add a ParameterResolver"},{"location":"writing-extensions/Creating-parameter-resolvers/#registering-the-parameter-resolver","text":"CommandsBuilder . newBuilder () . extensionsBuilder ( extensionsBuilder -> extensionsBuilder . registerParameterResolver ( new TimestampResolver ()) ) . build ( jda , \"com.freya02.bot.wiki.paramresolver.commands\" );","title":"Registering the parameter resolver"},{"location":"writing-extensions/Creating-parameter-resolvers/#using-these-parameters","text":"public class SlashParamResolverTest extends ApplicationCommand { @JDASlashCommand ( name = \"paramres\" ) public void run ( GuildSlashEvent event , @AppOption Timestamp timestamp ) { event . reply ( \"Your timestamp as relative: \" + TimeFormat . RELATIVE . format ( timestamp . getTimestamp ())). queue (); } }","title":"Using these parameters"},{"location":"writing-extensions/Field-injection/","text":"You might have a use case where your command needs specific objects from other instances (such as a database connection perhaps), normally you could pass them to your command constructors, but here your commands are constructed automatically, so manually doing it is not an option. That's why you can register field dependencies suppliers (or use constructor injection ) How to use them \u00b6 You can make these types of fields possible by using the @Dependency annotation: Example \u00b6 public class SlashFieldInjectionTest extends ApplicationCommand { @Dependency private BContext context ; @Dependency private Connection connection ; @JDASlashCommand ( name = \"fieldinj\" ) public void run ( GuildSlashEvent event ) { event . replyFormat ( \"My fields are %s and %s\" , context , connection ). queue (); } }","title":"Field injection"},{"location":"writing-extensions/Field-injection/#how-to-use-them","text":"You can make these types of fields possible by using the @Dependency annotation:","title":"How to use them"},{"location":"writing-extensions/Field-injection/#example","text":"public class SlashFieldInjectionTest extends ApplicationCommand { @Dependency private BContext context ; @Dependency private Connection connection ; @JDASlashCommand ( name = \"fieldinj\" ) public void run ( GuildSlashEvent event ) { event . replyFormat ( \"My fields are %s and %s\" , context , connection ). queue (); } }","title":"Example"}]}